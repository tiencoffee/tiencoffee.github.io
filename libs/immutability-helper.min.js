"use strict";var invariant=function(g,h,i,a,b,c,d,e){if(!g){var f;if(void 0===h)f=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var j=[i,a,b,c,d,e],k=0;f=new Error(h.replace(/%s/g,function(){return j[k++]})),f.name="Invariant Violation"}throw f.framesToPop=1,f}},hasOwnProperty=Object.prototype.hasOwnProperty,splice=Array.prototype.splice,toString=Object.prototype.toString;function type(a){return toString.call(a).slice(8,-1)}var assign=Object.assign||function(a,b){return getAllKeys(b).forEach(function(c){hasOwnProperty.call(b,c)&&(a[c]=b[c])}),a},getAllKeys="function"==typeof Object.getOwnPropertySymbols?function(a){return Object.keys(a).concat(Object.getOwnPropertySymbols(a))}:function(a){return Object.keys(a)};function copy(a){return Array.isArray(a)?assign(a.constructor(a.length),a):"Map"===type(a)?new Map(a):"Set"===type(a)?new Set(a):a&&"object"==typeof a?assign(Object.create(Object.getPrototypeOf(a)),a):a}var Context=function(){function a(){this.commands=assign({},defaultCommands),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(a,b){return a===b},this.update.newContext=function(){return new a().update}}return Object.defineProperty(a.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(a){this.update.isEquals=a},enumerable:!0,configurable:!0}),a.prototype.extend=function(a,b){this.commands[a]=b},a.prototype.update=function(a,b){var c=this,d="function"==typeof b?{$apply:b}:b;Array.isArray(a)&&Array.isArray(d)||invariant(!Array.isArray(d),"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."),invariant("object"==typeof d&&null!==d,"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the following commands: %s.",Object.keys(this.commands).join(", "));var e=a;return getAllKeys(d).forEach(function(b){if(hasOwnProperty.call(c.commands,b)){var f=a===e;e=c.commands[b](d[b],e,d,a),f&&c.isEquals(e,a)&&(e=a)}else{var g="Map"===type(a)?c.update(a.get(b),d[b]):c.update(a[b],d[b]),h="Map"===type(e)?e.get(b):e[b];c.isEquals(g,h)&&("undefined"!=typeof g||hasOwnProperty.call(a,b))||(e===a&&(e=copy(a)),"Map"===type(e)?e.set(b,g):e[b]=g)}}),e},a}();var defaultCommands={$push:function(a,b,c){return invariantPushAndUnshift(b,c,"$push"),a.length?b.concat(a):b},$unshift:function(a,b,c){return invariantPushAndUnshift(b,c,"$unshift"),a.length?a.concat(b):b},$splice:function(a,b,c,d){return invariantSplices(b,c),a.forEach(function(a){invariantSplice(a),b===d&&a.length&&(b=copy(d)),splice.apply(b,a)}),b},$set:function(a,b,c){return invariantSet(c),a},$toggle:function(a,b){invariantSpecArray(a,"$toggle");var c=a.length?copy(b):b;return a.forEach(function(a){c[a]=!b[a]}),c},$unset:function(a,b,c,d){return invariantSpecArray(a,"$unset"),a.forEach(function(a){Object.hasOwnProperty.call(b,a)&&(b===d&&(b=copy(d)),delete b[a])}),b},$add:function(a,b,c,d){return invariantMapOrSet(b,"$add"),invariantSpecArray(a,"$add"),"Map"===type(b)?a.forEach(function(a){var c=a[0],e=a[1];b===d&&b.get(c)!==e&&(b=copy(d)),b.set(c,e)}):a.forEach(function(a){b!==d||b.has(a)||(b=copy(d)),b.add(a)}),b},$remove:function(a,b,c,d){return invariantMapOrSet(b,"$remove"),invariantSpecArray(a,"$remove"),a.forEach(function(a){b===d&&b.has(a)&&(b=copy(d)),b.delete(a)}),b},$merge:function(a,b,c,d){return invariantMerge(b,a),getAllKeys(a).forEach(function(c){a[c]!==b[c]&&(b===d&&(b=copy(d)),b[c]=a[c])}),b},$apply:function(a,b){return invariantApply(a),a(b)}},defaultContext=new Context;function invariantPushAndUnshift(a,b,c){invariant(Array.isArray(a),"update(): expected target of %s to be an array; got %s.",c,a),invariantSpecArray(b[c],c)}function invariantSpecArray(a,b){invariant(Array.isArray(a),"update(): expected spec of %s to be an array; got %s. Did you forget to wrap your parameter in an array?",b,a)}function invariantSplices(a,b){invariant(Array.isArray(a),"Expected $splice target to be an array; got %s",a),invariantSplice(b.$splice)}function invariantSplice(a){invariant(Array.isArray(a),"update(): expected spec of $splice to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?",a)}function invariantApply(a){invariant("function"==typeof a,"update(): expected spec of $apply to be a function; got %s.",a)}function invariantSet(a){invariant(1===Object.keys(a).length,"Cannot have more than one key in an object with $set")}function invariantMerge(a,b){invariant(b&&"object"==typeof b,"update(): $merge expects a spec of type 'object'; got %s",b),invariant(a&&"object"==typeof a,"update(): $merge expects a target of type 'object'; got %s",a)}function invariantMapOrSet(a,b){var c=type(a);invariant("Map"===c||"Set"===c,"update(): %s expects a target of type Set or Map; got %s",b,c)}